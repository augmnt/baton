import { Command } from 'commander'
import prompts from 'prompts'
import { existsSync, readFileSync, writeFileSync } from 'fs'
import { join } from 'path'
import type { Hex } from 'viem'
import * as wallet from '../../modules/wallet.js'
import { fundAddress } from '../../modules/faucet.js'
import { colors, getBanner } from '../branding.js'

interface EnvVars {
  TEMPO_PRIVATE_KEY?: string
  TEMPO_NETWORK?: string
  TEMPO_RPC_URL?: string
}

function writeEnvFile(vars: EnvVars, envPath: string, merge = true): void {
  let existing: Record<string, string> = {}

  if (merge && existsSync(envPath)) {
    const content = readFileSync(envPath, 'utf-8')
    for (const line of content.split('\n')) {
      const trimmed = line.trim()
      if (trimmed && !trimmed.startsWith('#')) {
        const eqIndex = trimmed.indexOf('=')
        if (eqIndex > 0) {
          const key = trimmed.slice(0, eqIndex)
          const value = trimmed.slice(eqIndex + 1)
          existing[key] = value
        }
      }
    }
  }

  const merged = { ...existing, ...vars }
  const lines: string[] = [
    '# Baton Configuration',
    '# Generated by: baton init',
    '',
  ]

  for (const [key, value] of Object.entries(merged)) {
    if (value !== undefined) {
      lines.push(`${key}=${value}`)
    }
  }

  writeFileSync(envPath, lines.join('\n') + '\n')
}

export function createInitCommand(): Command {
  return new Command('init')
    .description('Initialize Baton with a new or existing wallet')
    .option('--force', 'Overwrite existing .env file without prompting')
    .action(async (options) => {
      console.log(getBanner())
      console.log(colors.accent.bold('\n  Welcome to Baton Setup\n'))

      const envPath = join(process.cwd(), '.env')
      const envExists = existsSync(envPath)

      // Check for existing .env
      if (envExists && !options.force) {
        const { overwrite } = await prompts({
          type: 'confirm',
          name: 'overwrite',
          message: 'A .env file already exists. Update it?',
          initial: true,
        })

        if (!overwrite) {
          console.log(colors.info('\nSetup cancelled. Your existing .env was not modified.'))
          return
        }
      }

      // Choose wallet setup method
      const { setupMethod } = await prompts({
        type: 'select',
        name: 'setupMethod',
        message: 'How would you like to set up your wallet?',
        choices: [
          { title: 'Create a new wallet', value: 'new' },
          { title: 'Import existing wallet (private key)', value: 'import-key' },
          { title: 'Import from mnemonic phrase', value: 'import-mnemonic' },
        ],
      })

      if (!setupMethod) {
        console.log(colors.info('\nSetup cancelled.'))
        return
      }

      let privateKey: Hex
      let address: string
      let mnemonic: string | undefined

      if (setupMethod === 'new') {
        // Generate new wallet
        const { withMnemonic } = await prompts({
          type: 'confirm',
          name: 'withMnemonic',
          message: 'Generate recovery phrase (mnemonic)? (Recommended)',
          initial: true,
        })

        const result = wallet.generateWallet(withMnemonic)
        privateKey = result.privateKey
        address = result.address
        mnemonic = result.mnemonic

        console.log(colors.success('\nâœ“ Wallet generated successfully!\n'))
        console.log(colors.dim('  Address:     ') + colors.accent(address))

        if (mnemonic) {
          console.log(colors.dim('  Mnemonic:    ') + colors.accent(mnemonic))
          console.log('')
          console.log(colors.warning('  âš ï¸  IMPORTANT: Write down your mnemonic phrase and store it safely!'))
          console.log(colors.warning('      This is the ONLY way to recover your wallet if you lose access.'))
          console.log(colors.warning('      Never share it with anyone.'))
        }

        console.log('')
        console.log(colors.warning('  âš ï¸  Your private key will be saved to .env'))
        console.log(colors.warning('      Make sure .env is in your .gitignore!'))

      } else if (setupMethod === 'import-key') {
        // Import from private key
        const { key } = await prompts({
          type: 'password',
          name: 'key',
          message: 'Enter your private key:',
          validate: (value: string) => {
            const normalized = value.startsWith('0x') ? value : `0x${value}`
            if (!/^0x[a-fA-F0-9]{64}$/.test(normalized)) {
              return 'Invalid private key format. Must be 64 hex characters (with or without 0x prefix)'
            }
            return true
          },
        })

        if (!key) {
          console.log(colors.info('\nSetup cancelled.'))
          return
        }

        privateKey = (key.startsWith('0x') ? key : `0x${key}`) as Hex
        address = wallet.deriveAddress(privateKey)

        console.log(colors.success('\nâœ“ Wallet imported successfully!\n'))
        console.log(colors.dim('  Address: ') + colors.accent(address))

      } else {
        // Import from mnemonic
        const { phrase } = await prompts({
          type: 'password',
          name: 'phrase',
          message: 'Enter your mnemonic phrase:',
          validate: (value: string) => {
            if (!wallet.validateMnemonic(value)) {
              return 'Invalid mnemonic phrase'
            }
            return true
          },
        })

        if (!phrase) {
          console.log(colors.info('\nSetup cancelled.'))
          return
        }

        const { index } = await prompts({
          type: 'number',
          name: 'index',
          message: 'Account index (0 for default):',
          initial: 0,
          min: 0,
          max: 100,
        })

        const result = wallet.deriveFromMnemonic(phrase, index ?? 0)
        privateKey = result.privateKey
        address = result.address

        console.log(colors.success('\nâœ“ Wallet imported successfully!\n'))
        console.log(colors.dim('  Address: ') + colors.accent(address))
      }

      // Choose network
      const { network } = await prompts({
        type: 'select',
        name: 'network',
        message: 'Which network would you like to use?',
        choices: [
          { title: 'Testnet (recommended for getting started)', value: 'testnet' },
          { title: 'Mainnet', value: 'mainnet' },
        ],
        initial: 0,
      })

      if (!network) {
        console.log(colors.info('\nSetup cancelled.'))
        return
      }

      // Save to .env
      const { saveEnv } = await prompts({
        type: 'confirm',
        name: 'saveEnv',
        message: 'Save configuration to .env file?',
        initial: true,
      })

      if (saveEnv) {
        writeEnvFile(
          {
            TEMPO_PRIVATE_KEY: privateKey,
            TEMPO_NETWORK: network,
          },
          envPath,
          envExists
        )
        console.log(colors.success('\nâœ“ Configuration saved to .env'))
      }

      // Offer faucet funding for testnet
      if (network === 'testnet') {
        // Set network for faucet check
        process.env.TEMPO_NETWORK = 'testnet'

        const { fundWallet } = await prompts({
          type: 'confirm',
          name: 'fundWallet',
          message: 'Fund wallet from testnet faucet? (Receives 1M of each token)',
          initial: true,
        })

        if (fundWallet) {
          console.log(colors.info('\nRequesting funds from faucet...'))
          try {
            const result = await fundAddress(address as Hex)
            if (result.success) {
              console.log(colors.success('âœ“ Funded successfully!'))
              console.log(colors.dim('  Transactions:'))
              for (const hash of result.transactionHashes) {
                console.log(colors.accent('    ' + hash))
              }
            } else {
              console.log(colors.warning('Faucet request failed. You can try again later with: baton faucet fund ' + address))
            }
          } catch {
            console.log(colors.warning('Faucet request failed. You can try again later with: baton faucet fund ' + address))
          }
        }
      }

      // Success message
      console.log('')
      console.log(colors.success.bold('ðŸš€ You\'re all set!\n'))
      console.log(colors.dim('  Try these commands:'))
      console.log(colors.accent(`    baton balances ${address.slice(0, 10)}...`))
      console.log(colors.accent('    baton chain info'))
      console.log(colors.accent('    baton --help'))
      console.log('')
    })
}
